#! /bin/bash

function compute_swap () {
  # swap fixed to installed RAM, but must be shrunk if RAM > .25*hdsize
  # measure in bytes!

  typeset -i memsize mem_mib disk_eighth $2

  set `grep MemTotal /proc/meminfo`
  # Convert size to 1MiB blocks
  case $3 in
    kB) memsize=$2/1024;;
    MB) memsize=$2;;
    GB) memsize=$2*1024;;
    TB) memsize=$2*1024**2;;
    *) memsize=$2/1024;;      # Assume it is kB
  esac

  # If memory is > 1/8 of the disk, crowbar swap to 1/8 of the disk
  disk_eighth=remainder/8
  if [ $memsize -lt $disk_eighth ]; then
    # Base swap on memory size
    swapMiB=memsize
    swapsize=swapMiB
  else
    # Base swap on 1/8 disk size
    swapMiB=disk_eighth
    swapsize=swapMiB
  fi
}

# sed changes this to the currently used kernel version
#
KERNEL_VER=KeRnElVeRsIoN

# set ATIME first thing
  case $noatime in
    1) ATIME="";;
    2) ATIME=",noatime";;
    *) ATIME="";;
  esac

CONFIG_ROOT=/var/smoothwall

TITLE="$CLS           ${BOUL}Smoothwall Express 3 (Roadster Test Vehicle) Installation$NO"

echo -e "$TITLE"
echo
echo "Tweaking udev"
echo "Tweaking udev" >/dev/tty2
  echo "  Rules"
  (
    echo "# Phaeton/Roadster persistent device names"
    echo
    echo "# Auto-generated by installation program: `date`"
    
    echo "    /dev/harddisk's name" >/dev/tty
    echo "# hard drive's symlink"
    echo "SUBSYSTEM==\"block\",KERNEL==\"[hs]d*|cciss*\",ENV{DEVTYPE}==\"disk\",ENV{ID_SERIAL_SHORT}==\"${hd_id[$hd]}\", SYMLINK+=\"harddisk\""
    echo "SUBSYSTEM==\"block\",KERNEL==\"[hs]d*|cciss*\",ENV{DEVTYPE}==\"partition\",ENV{ID_SERIAL_SHORT}==\"${hd_id[$hd]}\", SYMLINK+=\"harddisk%n\""
    echo
    
  ) > /etc/udev/rules.d/70-Smoothwall-custom-disk.rules

  echo "    Persistent custom NIC names"
  (
    echo "# Phaeton/Roadster persistent custom NIC names"
    echo
    echo "# Auto-generated by installation program: `date`"
    
    echo "# Persistent NIC names"
    # not doing custom NIC names for now
    #
    cat /etc/udev/rules.d/70-persistent-net.rules
    if [ 1 -lt 0 ]; then
    typeset -i i
    i=1
    while [ $i -lt $nic_cnt ]; do
      if [ "${CLR[$i]}" != "not named" ]; then
        echo -n "SUBSYSTEM==\"net\", ACTION==\"add\", DRIVERS==\"?*\","
        echo -n " ATTR{address}==\"`cat /sys/class/net/${DEV[$i]}/address`\","
        echo " ATTR{type}==\"1\", KERNEL==\"eth*\", NAME=\"${CLR[$i]}\""
      fi
      i=i+1
    done
    fi # skip NIC names
  ) > /etc/udev/rules.d/70-Smoothwall-custom-NIC.rules

  echo "  Triggering udev and waiting for it to settle"
  do_or_die "/sbin/udevadm trigger --subsystem-match=net"
  do_or_die "/sbin/udevadm trigger --subsystem-match=block"
  do_or_die "/sbin/udevadm settle"

  sleep 2


echo -e "$TITLE"
echo
echo "Partitioning hard drive"
echo "Partitioning hard drive" >/dev/tty2
echo
  typeset -i remainder bootsize swapsize rootsize logsize memsize
  typeset -i grubMiB bootMiB swapMiB rootMiB logMiB
  typeset -i grubstart bootstart swapstart rootstart logstart
  typeset -i grubend bootend swapend rootend logend
  typeset -i sTotal hw_sector_size unused unusedMiB

  # Get disk parameters
  hdd="${hd_dev[$hd]}"
  hw_sector_size=`cat /sys/block/$hdd/queue/hw_sector_size 2>/dev/null`
  if [ "$hw_sector_size" -eq 0 ]; then hw_sector_size=512; fi
  sTotal=`cat /sys/block/$hdd/size`
  sTotal=sTotal*$hw_sector_size/1024**2

  # Find out how much we're to use: all or part
  if [ $maxMiB -eq 0 ]; then
    remainder=$sTotal
    unused=0
  else
    remainder=$maxMiB
    unused=sTotal-remainder
  fi

  # Compute partition sizes
  #
  # boot partition fixed size
  bootMiB=200
  bootsize=bootMiB                   # 200MiB
  bootstart=3                        # 3 MiB
  bootend=bootstart+bootsize-1
  echo "  ${hdd}1  ${bootMiB}MiB -> /boot"

  # swap partition fixed size
  remainder=remainder-4            # less one MiB at each end, less 2MiB bios_grub
  compute_swap                     # swapsize is based on memory vs. disk size
  swapstart=bootend+1
  swapend=swapstart+swapsize-1
  echo "  ${hdd}2  ${swapMiB}MiB -> swap"

  # log partition: 1/3 remainder
  remainder=remainder-bootsize-swapsize
  logMiB=remainder/3
  #logMiB=logMiB/1024/2
  logsize=logMiB
  logstart=swapend+1
  logend=logstart+logsize-1
  echo "  ${hdd}3  ${logMiB}MiB -> /log"

  # root partition: remainder
  remainder=remainder-logsize
  rootMiB=remainder
  rootsize=rootMiB
  rootstart=logend+1
  rootend=rootstart+rootsize-1
  echo "  ${hdd}4  ${rootMiB}MiB -> / (root)"

  # grub_bios partition: before /boot
  grubMiB=2
  grubsize=grubMiB
  grubstart=1
  grubend=grubstart+grubsize-1
  echo "  ${hdd}5  ${grubMiB}MiB -> grub_bios"

  # all that's left
  remainder=remainder-rootsize
  unused=unused+remainder
  unusedMiB=unused
  echo "           ${unusedMiB}MiB -> (free space)"

  # prep the input
  cat <<END >/tmp/partitions
unit MiB
select /dev/$hdd
mklabel gpt
mkpart boot reiserfs $bootstart $bootend
name 1 "/boot"
mkpart swap linux-swap $swapstart $swapend
name 2 swap
mkpart log reiserfs $logstart $logend
name 3 "/var/log"
mkpart root reiserfs $rootstart $rootend
name 4 "/"
mkpart bios_grub $grubstart $grubend
set 5 bios_grub on
name 5 "bios_grub"
print
quit
END

  echo
  do_or_die "dd if=/dev/zero of=/dev/$hdd bs=512 count=34"
  do_or_die "parted /dev/$hdd </tmp/partitions"

  sleep 2

echo -e "$TITLE"
echo
echo "Preparing filesystems"
echo "Preparing filesystems" >/dev/tty2
echo
  if [ $filesys -eq 1 ]; then MKFS="mke2fs -FFj"; else MKFS="mkreiserfs -ff"; fi
  echo "  /boot"
  do_or_die "$MKFS /dev/harddisk1"
  echo "  swap"
  do_or_die "mkswap /dev/harddisk2"
  echo "  /var/log"
  do_or_die "$MKFS /dev/harddisk3"
  echo "  /"
  do_or_die "$MKFS /dev/harddisk4"

  echo
  echo "Enabling swap"
  do_or_die "swapon /dev/harddisk2"


# If installing with or without a var data restore, mount the source medium
if [ $restore -eq 1 -o $restore -eq 2 ]; then
  # Confuser: First try to mount the whole medium as an ISO9660 CD-/DVD-ROM;
  # failing that, try mounting it as type 'isofs'. Failing that, try mounting
  # partition #1 as VFAT.
  echo "Mounting source media"
  CDMNTLOG="/cdmount.log"
  > $CDMNTLOG
  mount -t iso9660  /dev/${cd_dev[$CD]}  /cdrom -o ro >> $CDMNTLOG 2>&1 \
  || mount -t isofs /dev/${cd_dev[$CD]}  /cdrom -o ro >> $CDMNTLOG 2>&1 \
  || mount -t vfat  /dev/${cd_dev[$CD]}1 /cdrom -o rw >> $CDMNTLOG 2>&1
  if [ $? -ne 0 ]; then
    echo "Couldn't mount source medium:"
    sed -e 's/^/  /' $CDMNTLOG
    echo
    echo "Press <ENTER> to reboot the system and try again."
    read a
    reboot -f
  fi
fi

# Mount the restore drive if restoring anything
if [ $restore -eq 2 -o $restore -eq 3 ]; then
  echo "Mounting restore drive"
  mkdir -p /restore
  RDMNTLOG="/tmp/rdmount.log"
  > $RDMNTLOG
  mount /dev/${rd_dev[$rd]}1  /restore -o ro >> $RDMNTLOG 2>&1
  if [ $? -ne 0 ]; then
    echo "Couldn't mount restore drive:"
    sed -e 's/^/  /' $RDMNTLOG
    echo
    echo "Press <ENTER> to reboot the system and try again."
    read a
    reboot -f
  fi
fi

  if [ $filesys -eq 1 ]; then FS="-t ext3"; else FS="-t reiserfs"; fi
  echo "Mounting new root filesystem"
  do_or_die "mount $FS /dev/harddisk4 /harddisk"

  echo "Mounting /boot and /var/log"
  mkdir -p -m 755 /harddisk/boot /harddisk/var/log
  do_or_die "mount $FS /dev/harddisk1 /harddisk/boot"
  do_or_die "mount $FS /dev/harddisk3 /harddisk/var/log"

  sleep 2

echo -e "$TITLE"
echo
echo "Preparing Smoothwall"
echo "Preparing Smoothwall" >/dev/tty2
echo

GRUB_CMD="/usr/sbin/grub-install"

# If installing or restoring var data
if [ $restore -eq 1 -o $restore -eq 2 ]; then
  echo "  unpacking system"
  do_or_die "tar -C /harddisk -zxvf /cdrom/smoothwall.tgz"

  if [ $dev -eq 2 ]; then
    echo "    build tools"
    do_or_die "/bin/tar -C /harddisk -zxvf /cdrom/smoothdev.tgz"
    echo "    build docs & headers"
    do_or_die "/bin/tar -C /harddisk -zxvf /cdrom/smoothdoc.tgz"
  fi

  echo "  copying udev rules to target"
    do_or_die "mkdir -p -m 755 /harddisk/etc/udev/rules.d"
    do_or_die "cp -v /etc/udev/rules.d/*Smoothwall* /harddisk/etc/udev/rules.d/"

  echo "  creating new fstab, modules and mtab"
  set -- $FS

  echo >/dev/tty2
  OPTION="defaults$ATIME"
  FSTYPE=$2
  if [ "$FSTYPE" == "reiserfs" ]; then
    ROOTOPTION="notail$ATIME    "
  else
    ROOTOPTION=$OPTION
  fi
  (
    echo "proc            /proc           proc            defaults        0       0"
    echo "sys             /sys            sysfs           defaults        0       0"
    echo "dev             /dev            devtmpfs        defaults        0       0"
    echo "devpts          /dev/pts        devpts          defaults        0       0"
    echo "/dev/harddisk2  none            swap            sw              0       0"
    echo
    echo "/dev/harddisk4  /               $FSTYPE         $ROOTOPTION           0       1"
    echo "/dev/harddisk1  /boot           $FSTYPE         $OPTION  0       2"
    echo "/dev/harddisk3  /var/log        $FSTYPE         $OPTION  0       2"
  ) >/harddisk/etc/fstab
  echo "$FTYPE" >/harddisk/etc/modules

  do_or_die ">/harddisk/etc/mtab; chmod 644 /harddisk/etc/mtab"
  do_or_die "/bin/chroot /harddisk /bin/mount -f /proc"
  do_or_die "/bin/chroot /harddisk /bin/mount -f /sys"
  do_or_die "/bin/chroot /harddisk /bin/mount -f /dev"
  do_or_die "/bin/chroot /harddisk /bin/mount -a -f"
  
  echo "  saving configs and settings"
  cat <<END > /harddisk/$CONFIG_ROOT/main/hwprofile
STORAGE_DEVNODE=harddisk
CDROM_DEVNODE=${cd_dev[$CD]}
STORAGE_DRIVER=
STORAGE_DRIVER_OPTIONS=
END

  uname -r >/harddisk/$CONFIG_ROOT/main/kernel

  cat <<END >/harddisk/$CONFIG_ROOT/main/settings
LANGUAGE=en
HOSTNAME=smoothwall
KEYMAP=/usr/share/kbd/keymaps/i386/qwerty/us.map.gz
OPENNESS=halfopen
END

  echo "  prepping module dependencies"
  do_or_die "/bin/chroot /harddisk /sbin/depmod -a"

  if [ $serialport -eq 2 -o $serialport -eq 3 ]; then
    echo "  enabling getty on ttyS0"
    sed -i -e'/^S0/ s/off/respawn/' /harddisk/etc/inittab
  fi

  echo "  adjusting runtime initramfs"
  set -- $FS
  FSTYPE=$2
  if [ "$FSTYPE" == "reiserfs" ]; then
    OPTION="notail$ATIME        "
  else
    OPTION="defaults$ATIME"
  fi

  OPWD=`pwd`
  HDTMP="/harddisk/runtimeroot"
  mkdir -p $HDTMP; cd $HDTMP
  echo "    unpack"
  do_or_die "gunzip -c /harddisk/boot/initrd-${KERNEL_VER}-roadster.gz | cpio -id"
  echo "    update"
  do_or_die "mkdir -p -m 755 ${HDTMP}/etc/udev/rules.d"
  do_or_die "cp -v /etc/udev/rules.d/*Smoothwall* ${HDTMP}/etc/udev/rules.d/"

  (
    echo "/dev/harddisk4	/harddisk	$FSTYPE	$OPTION		0	1"
  ) >${HDTMP}/etc/fstab
  echo "$FSTYPE" >${HDTMP}/etc/modules
  do_or_die "/bin/chroot ${HDTMP} /sbin/depmod -a"

  echo "    re-pack"
  do_or_die "cd ${HDTMP}; find . | /bin/cpio -o -H newc | /usr/bin/gzip > /harddisk/boot/initrd-${KERNEL_VER}-roadster.gz"
  do_or_die "chmod 444 /harddisk/boot/initrd-${KERNEL_VER}-roadster.gz"
  cd ${OPWD}
  rm -rf ${HDTMP}

  echo "  configuring boot loader"
  cat > /harddisk/boot/grub/grub.conf <<END
# Begin /boot/grub/grub.conf

# Set up to output to both VGA console and serial port; grub'll
#   use the first one to see a keypress. Or it'll time out and
#   use the default from installation (the first one in the command).
#   Change the order of them if you manually change between serial
#   and vesa.

serial --unit=0 --speed=115200
END

  if [ $serialport -eq 1 -o $serialport -eq 3 ]; then
    cat >> /harddisk/boot/grub/grub.conf <<END
terminal --timeout=5 serial console

# Boot using serial console by default
default 1
END
  else
    cat >> /harddisk/boot/grub/grub.conf <<END
terminal --timeout=5 console serial

# Boot using VESA console
default 0
END
  fi

  cat >> /harddisk/boot/grub/grub.conf <<END

# Allow 10 seconds before booting the default.
timeout 10

# Use prettier colors (OR/BK, YL/BK).
color 0x06 0x0e

# Boot using VESA console
title AGCL/Roadster (VESA Console)
root (hd0,0)
kernel /vmlinuz-${KERNEL_VER}-roadster root=/dev/harddisk4 ro quiet
initrd /initrd-${KERNEL_VER}-roadster.gz

# Boot using serial console
title AGCL/Roadster (Serial Console)
root (hd0,0)
kernel /vmlinuz-${KERNEL_VER}-roadster root=/dev/harddisk4 ro quiet console=ttyS0,115200
initrd /initrd-${KERNEL_VER}-roadster.gz

# Single-user using VESA console
title AGCL/Roadster (VESA Console, Single-User)
root (hd0,0)
kernel /vmlinuz-${KERNEL_VER}-roadster root=/dev/harddisk4 ro quiet single
initrd /initrd-${KERNEL_VER}-roadster.gz

# Single-user using serial console
title AGCL/Roadster (Serial Console, Single-User)
root (hd0,0)
kernel /vmlinuz-${KERNEL_VER}-roadster root=/dev/harddisk4 ro quiet console=ttyS0,115200 single
initrd /initrd-${KERNEL_VER}-roadster.gz
END

  # Restore variable data if selected. AND upgrade files as needed!
  if [ $restore -eq 2 ]; then
    (cd /harddisk/etc; for file in passwd group shadow; do cp $file $file-FRESH; done)
    (cd /harddisk/var/smoothwall/main; mv productdata productdata-FRESH)
    echo "  Restoring variable data from backup"
    do_or_die "tar -C /harddisk -zxvf /restore/${archive_id[$archive]}"
    echo "  Upgrading variable data files"
    (cd /harddisk/var/smoothwall/main; mv productdata-FRESH productdata)
    (
      cd /harddisk/etc
      for file in passwd group shadow; do cp $file $file-RESTORED; done
      (
        egrep "fuse|plugdev|scanner|kvm|usbmux" group-FRESH
        egrep -v "fuse|plugdev|scanner|kvm|usbmux" group-RESTORED
      ) | sort -n -t: -k 3,3 >group
      (
        egrep "usbmux" passwd-FRESH
        egrep -v "usbmux" passwd-RESTORED
      ) | sort -n -t: -k 3,3 >passwd
      # DON'T sort shadow
      (
        egrep -v "usbmux" shadow-RESTORED
        egrep "usbmux" shadow-FRESH
      ) >shadow
    )
    # Sweep the detritus under the rug
    (cd /harddisk/etc; rm -f {passwd,group,shadow}-{RESTORED,FRESH})
    GRUB_CMD="$GRUB_CMD --recheck"
  fi

else

  # Performing a total restore
  echo "  Restoring complete system from backup"
  do_or_die "tar -C /harddisk -zxvf /restore/${archive_id[$archive]}"

  # Sweep some backup crumbs under the rug
  rm -f /harddisk/boot/grub/device.map  # map might've changed
  > /harddisk/etc/mtab                  # It's wrong anyway
  chroot /harddisk mount -f -a          # Make it match 'now'

  GRUB_CMD="$GRUB_CMD --recheck"
fi

# Always install the boot loader whether installing, restoring var or
#   doing a total restore
echo "  installing boot loader"
do_or_die "mount --bind /proc /harddisk/proc"
do_or_die "mount --bind /sys /harddisk/sys"
do_or_die "mount --bind /dev /harddisk/dev"
cat<<END >/harddisk/tmp/grub.cmds
device (hd0) /dev/harddisk
root (hd0,0) 
setup (hd0) 
quit
END
do_or_die "/sbin/chroot /harddisk /usr/sbin/grub --batch </harddisk/tmp/grub.cmds"


sleep 2

echo -e "$TITLE"
echo
echo "Installation is complete."

sleep 2
